$cx adap

ltoa{list}:(>list[;0];(listû2!list)[;1])

getopt{list;key;default}:if (keyÅ0Ølist) keyØlist else default

getretryarg{service}:4«if (`retryÅ0Øsfû_alsf{service}){ `retryØsf } else{ 1 }


CBFunctionsû();
CBHandlesûÉ0;

TweakAArgument{a}:{
  newsymsû`opened`closed;
  oldsymsû`connected`reset;
  if((~`sym½©a)©(~(É0)½Òa)) a else if (aÅnewsyms) oldsyms[newsymsÉa] else a
} 

ConnectionCallbackPassthru{h;a;d}:{
  aûTweakAArgument{a};
  if (`connected½a) {
    if (~hÅadap.CBHandles) {
      lstnûi.getattr{h;`listener};
      if ((~0½lstn)^(~()½lstn)) {
        adap.CBHandlesûadap.CBHandles,h;
        adap.CBFunctionsûadap.CBFunctions,adap.CBFunctions[adap.CBHandlesÉlstn];
      } else {
        Õ"ã Warning `connect event received for an unknown possibly closed handle:",îh;
        û();
      };
    };
  };
  if (hÅadap.CBHandles) {(adap.CBFunctions[adap.CBHandlesÉh])¡{h;a;d}}
  else adap.ConnectCBFunction{h;a;d};
}

filterConnectArgs{name;host;port;protocol}:{
  if(protocol½`RAW) protocolû`raw;
  if(host½()) hostû`localhost;
  (name;host;port;protocol)
}

Connect{service_descriptor;callbackfn}:{
  serviceargû_alsf { service_descriptor };
  hostûgetopt{servicearg;`host;`localhost};
  portûgetopt{servicearg;`port;};
  protocolûgetopt{servicearg;`protocol;`A};
  nameûgetopt{servicearg;`name;`None};
  (name;host;port;protocol)ûfilterConnectArgs{name;host;port;protocol};

  adap.ConnectCBFunctionûcallbackfn;
  if(()½port) {
    if(^/`name`protocolÅ0Øservicearg) {
      hûi.connectNP{adap.ConnectionCallbackPassthru;name;protocol};
    } else if (`nameÅ0Øservicearg) {
      hûi.connectN{adap.ConnectionCallbackPassthru;name}
    } else hû¢1;
  } else {
    hûi.connectNHPP{adap.ConnectionCallbackPassthru;name;host;port;protocol}
 };
  if(¢1¨h) {
    adap.CBHandlesûadap.CBHandles,h;
    adap.CBFunctionsûadap.CBFunctions,<{callbackfn};
    i.open{ h };
  };
  h
}

Listen{service_descriptor;callbackfn}:{
  serviceargû_alsf{ service_descriptor};
  retryargûgetopt{servicearg;`retry;1};
  portûgetopt{servicearg;`port;};
  protocolûgetopt{servicearg;`protocol;`A};
  nameûgetopt{servicearg;`name;`None};
  (name;junk;port;protocol)ûfilterConnectArgs{name;`localhost;port;protocol};

  adap.ConnectCBFunctionûcallbackfn;
ãããããããããããããããã
  if(()½port) {
    if(^/`name`protocolÅ0Øservicearg) {
      hûi.listenNP{adap.ConnectionCallbackPassthru;name;protocol};
    } else if (`nameÅ0Øservicearg) {
      hûi.listenN{adap.ConnectionCallbackPassthru;name}
    } else hû¢1;
  } else {
    hûi.listenNPP{adap.ConnectionCallbackPassthru;name;port;protocol}
  };
ãããããããããããããããã
ã   hûi.listenNPP{adap.ConnectionCallbackPassthru;name;port;protocol};
ãããããããããããããããã
  if(¢1¨h) {
    i.setattr{h;`retry;retryarg};
    adap.CBHandlesûadap.CBHandles,h;
    adap.CBFunctionsûadap.CBFunctions,<{callbackfn};
    i.open{h};
  };
  h
}

Export a:if(()½aûsys.exp{a}){''} else {a}

Import a:if(()½aûsys.imp{a}){''} else {a}

adap.SyncXch{h;outgoing;to}:{
  timeoutû to;
  if ((()½timeout)^~()½to) Ù`domain;

  readPauseûi.getattr{h;`readPause};
  if(readPause=0) i.setattr{h;`readPause;1};
  resûi.syncsend{h;outgoing;timeout};
  if(`error½0Øres) {
      if(readPause=0) i.setattr{h;`readPause;readPause};
     ûres,<`send;
  };

  resûi.syncread{h;timeout};
  if(readPause=0) i.setattr{h;`readPause;readPause};
  if(`error½0Øres) ûres,<`read;

  0 1#res
}

WriteQueueStatus{h}:{i.getattr{h;`writeStatus}}

ReadQueueStatus{h}:{i.getattr{h;`readStatus}}

SetDebug{h;val}: i.setdebug{h;val}

Debug{val}: i.debug{val}

Reset{h}: i.close{h}

Send{h;msg}: i.send{h;msg}

Close{h}: {
  zûi.destroy{h};
  if(0Åbûadap.CBHandles¨h) {
    adap.CBFunctionsûb/adap.CBFunctions;
    adap.CBHandlesûb/adap.CBHandles;
  };
  z
}

SetClientData{h;val}: {
  attrû`clientData`eventData[`timer½0#i.whatis{h}];
  i.setattr{h;attr;val}
}

GetClientData{h}:{
  attrû`clientData`eventData[`timer½0#i.whatis{h}];
  i.getattr{h;attr}
}

Syncread{h;timeout}: i.syncread{h;timeout}

Syncsend{h;msg;timeout}: i.syncsend{h;msg;timeout}

Getfd{h}: i.getattr{h;`fd}

GetPort{h}: i.getattr{h;`port}

ATTRMATû2!(`rPriority `readPriority `wPriority `writePriority
  `rQueueStatus `readStatus `wQueueStatus `writeStatus
  `rPause `readPause `wPause `writePause
  `rBufsize `readBufsize `wBufsize `writeBufsize
  `rEventMode `burstMode `wNoDelay `noDelay)

adap2ipc{attr}:if((#ATTRMAT)>idxûATTRMAT[;0]Éattr) ATTRMAT[idx;1] else attr

Of{h;arg}:{
  zûif (`list½arg) { i.attrs{h} } else {i.getattr{h;adap2ipc { arg }} };
  if((`rEventMode½arg)^(z½0)©z½1)zû`single`burst[z];
  z
}

setattrCover{h;arg;val}:{
  if(`rEventMode½arg)valûval½`burst;
  i.setattr{h;adap2ipc {arg};val}
}


Has{h;arg}:{
  sfû_alsf{arg};
  (iû#0Øsf) do setattrCover{h;iØ0Øsf;iØ1Øsf};
}