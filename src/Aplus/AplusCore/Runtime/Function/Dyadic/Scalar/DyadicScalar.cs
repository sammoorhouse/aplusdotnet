using System;
using System.Collections.Generic;
using System.Reflection;

using AplusCore.Types;

namespace AplusCore.Runtime.Function.Dyadic.Scalar
{
    abstract class DyadicScalar : AbstractDyadicFunction
    {
        #region Variables

        private ATypes defaultResultType;
        private byte combination;

        /// <summary>
        /// Stores the allowed methods. The key is a combination generated by <see cref="CombinationKey"/>,
        /// which uses the method arguments' type to create a byte key value.
        /// </summary>
        private Dictionary<byte, MethodInfo> allowedMethods;

        #endregion

        #region Constructor

        public DyadicScalar()
        {
            this.allowedMethods = new Dictionary<byte, MethodInfo>();
            Type currentType = this.GetType();

            DefaultResultAttribute attribute = currentType.GetSingleAttribute<DefaultResultAttribute>();
            this.defaultResultType = (attribute != null) ? attribute.DefaultType : ATypes.AType;

            MethodInfo[] methods = currentType.GetMethods(
                BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public
            );

            // Detect the methods and add a rule for it based on the parameter types
            foreach (MethodInfo method in methods)
            {
                DyadicScalarMethodAttribute scalarAttribute =
                    method.GetSingleAttribute<DyadicScalarMethodAttribute>();

                if (scalarAttribute == null)
                {
                    continue;
                }

                ParameterInfo[] parameterInfo = method.GetParameters();

                // Add the method to the allowed method's list
                this.allowedMethods.Add(
                    CombinationKey(
                        Utils.GetATypesFromType(parameterInfo[0].ParameterType),
                        Utils.GetATypesFromType(parameterInfo[1].ParameterType)
                    ),
                    method
                );
            }
        }

        #endregion

        #region Private methods

        /// <summary>
        /// Returns an byte mask representing the type combination
        /// </summary>
        /// <param name="rightArgType">converted to int and shifted by 4</param>
        /// <param name="leftArgType">converted to int</param>
        /// <returns>type combination byte mask</returns>
        private byte CombinationKey(ATypes rightArgType, ATypes leftArgType)
        {
            return (byte)((((int)rightArgType) << 4) | ((int)leftArgType));
        }

        #endregion

        #region Entry Point from DLR

        public override AType Execute(AType right, AType left, AplusEnvironment environment = null)
        {
            this.combination = CombinationKey(right.Type, left.Type);
            if (right.Type == ATypes.ANull || left.Type == ATypes.ANull)
            {
                this.combination = CombinationKey(ATypes.ANull, ATypes.ANull);
            }
            // Check if we have a rule for the specific input types
            else if (!this.allowedMethods.ContainsKey(this.combination))
            {
                // Rule not found
                // reset the combination info to the default case
                this.combination = CombinationKey(ATypes.AType, ATypes.AType);
                // throw an error if we don't have a default case
                if (!this.allowedMethods.ContainsKey(this.combination))
                {
                    // throw a type error
                    throw new Error.Type(this.TypeErrorText);
                }
            }

            return ExecuteRecursion(right, left);
        }

        #endregion

        #region Recursion

        private AType ExecuteRecursion(AType rightArgument, AType leftArgument)
        {
            AType result;

            if (leftArgument.IsArray && rightArgument.IsArray)
            {
                if (leftArgument.Length != rightArgument.Length)
                {
                    throw new Error.Length(this.LengthErrorText);
                }

                AType currentItem;
                uint floatTypeCounter = 0;

                result = AArray.Create(ATypes.AArray);

                for (int i = 0; i < leftArgument.Length; i++)
                {
                    currentItem = ExecuteRecursion(rightArgument[i], leftArgument[i]);
                    floatTypeCounter += (uint)((currentItem.Type == ATypes.AFloat) ? 1 : 0);

                    result.AddWithNoUpdate(currentItem);
                }
                result.UpdateInfo();

                if (leftArgument.Length == 0 && rightArgument.Length == 0)
                {
                    result.Type = 
                        (this.defaultResultType != ATypes.AType) ? this.defaultResultType : ATypes.ANull;
                }

                // If one element was not as the others then the typeCounter will be
                // in an interval of:  0 < typeCounter < itemCount
                if ((floatTypeCounter != result.Length) && (floatTypeCounter != 0))
                {
                    result.ConvertToFloat();
                }
            }
            else if (leftArgument.IsArray && !rightArgument.IsArray)
            {
                if (rightArgument.Type == ATypes.ANull)
                {
                    throw new Error.Length(this.LengthErrorText);
                }

                AType currentItem;
                uint floatTypeCounter = 0;

                result = AArray.Create(ATypes.AArray);

                for (int i = 0; i < leftArgument.Length; i++)
                {
                    currentItem = ExecuteRecursion(rightArgument, leftArgument[i]);
                    floatTypeCounter += (uint)((currentItem.Type == ATypes.AFloat) ? 1 : 0);

                    result.AddWithNoUpdate(currentItem);
                }
                result.UpdateInfo();

                if (leftArgument.Length == 0)
                {
                    result.Type =
                        (this.defaultResultType != ATypes.AType) ? this.defaultResultType : rightArgument.Type;
                }

                if ((floatTypeCounter != result.Length) && (floatTypeCounter != 0))
                {
                    result.ConvertToFloat();
                }
            }
            else if (!leftArgument.IsArray && rightArgument.IsArray)
            {
                if (leftArgument.Type == ATypes.ANull)
                {
                    throw new Error.Length(this.LengthErrorText);
                }

                AType currentItem;
                uint floatTypeCounter = 0;

                result = AArray.Create(ATypes.AArray);

                for (int i = 0; i < rightArgument.Length; i++)
                {
                    currentItem = ExecuteRecursion(rightArgument[i], leftArgument);
                    floatTypeCounter += (uint)((currentItem.Type == ATypes.AFloat) ? 1 : 0);

                    result.AddWithNoUpdate(currentItem);
                }
                result.UpdateInfo();

                if (rightArgument.Length == 0)
                {
                    result.Type =
                        (this.defaultResultType != ATypes.AType) ? this.defaultResultType : leftArgument.Type;
                }

                if ((floatTypeCounter != result.Length) && (floatTypeCounter != 0))
                {
                    result.ConvertToFloat();
                }
            }
            else if (this.combination == CombinationKey(ATypes.ANull, ATypes.ANull))
            {
                return Utils.ANull();
            }
            else
            {
                // Get the method for the current input type combination
                MethodInfo method = this.allowedMethods[this.combination];

                try
                {
                    // Invoke the method
                    result = (AType)method.Invoke(this, new object[] { rightArgument.Data, leftArgument.Data });
                }
                catch (TargetInvocationException ex)
                {
                    // Exception during method invoke

                    // Check if the inner exception was an A+ Error?    
                    if (ex.InnerException is Error)
                    {
                        // A+ Error during the method invoke
                        throw ex.InnerException; // we lose stack trace this way, but its okay :)
                    }
                    else
                    {
                        throw;
                    }
                }
            }

            return result;
        }

        #endregion
    }
}
